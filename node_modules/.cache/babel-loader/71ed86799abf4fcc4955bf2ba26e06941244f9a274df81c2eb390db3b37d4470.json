{"ast":null,"code":"import React,{useState,useEffect,useRef}from\"react\";import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const DefinitionMatch=_ref=>{let{words,onAnswer}=_ref;const[selectedWord,setSelectedWord]=useState(null);const[selectedDefinition,setSelectedDefinition]=useState(null);const[matchedPairs,setMatchedPairs]=useState(new Set());const[shuffledDefinitions,setShuffledDefinitions]=useState([]);const[animatingMatch,setAnimatingMatch]=useState(null);const[incorrectMatch,setIncorrectMatch]=useState(null);const[attemptInProgress,setAttemptInProgress]=useState(false);const lastAttemptTimeRef=useRef(0);useEffect(()=>{// Shuffle definitions when component mounts or words change\nconst definitions=words.map(word=>word.definition);setShuffledDefinitions([...definitions].sort(()=>Math.random()-0.5));// Clear processed attempts when words change (fresh start for each exercise)\nlastAttemptTimeRef.current=0;},[words]);const makeAttempt=(word,definition)=>{if(attemptInProgress){return;}// Simple time-based debounce - prevent attempts within 100ms of each other\nconst now=Date.now();if(now-lastAttemptTimeRef.current<100){return;}setAttemptInProgress(true);lastAttemptTimeRef.current=now;// Clear selections immediately to prevent double-calls\nsetSelectedWord(null);setSelectedDefinition(null);const isCorrect=word.definition===definition;// Call onAnswer only once per attempt\nonAnswer(isCorrect);if(isCorrect){// Start connection animation\nsetAnimatingMatch({wordId:word.id,definition});// After animation, add to matched pairs\nsetTimeout(()=>{setMatchedPairs(prev=>{const newSet=new Set(prev);newSet.add(word.id);return newSet;});setAnimatingMatch(null);setAttemptInProgress(false);},1200);// Animation duration\n}else{// Show incorrect match animation\nsetIncorrectMatch({wordId:word.id,definition});// After showing red feedback, clear it\nsetTimeout(()=>{setIncorrectMatch(null);setAttemptInProgress(false);},800);// Shorter duration for incorrect feedback\n}};const handleWordClick=word=>{if(matchedPairs.has(word.id)||animatingMatch||incorrectMatch){return;}if(selectedDefinition){// We have a definition selected, make the attempt\nmakeAttempt(word,selectedDefinition);}else{// Just select the word\nsetSelectedWord(word);setSelectedDefinition(null);}};const handleDefinitionClick=definition=>{if(animatingMatch||incorrectMatch){return;// Prevent clicks during animation\n}if(selectedWord){// We have a word selected, make the attempt\nmakeAttempt(selectedWord,definition);}else{// Just select the definition\nsetSelectedDefinition(definition);setSelectedWord(null);}};// Filter out matched words and definitions\nconst availableWords=words.filter(word=>!matchedPairs.has(word.id));const availableDefinitions=shuffledDefinitions.filter(definition=>{// Find the word that has this definition\nconst wordWithDefinition=words.find(word=>word.definition===definition);return wordWithDefinition&&!matchedPairs.has(wordWithDefinition.id);});return/*#__PURE__*/_jsxs(\"div\",{className:\"match-container\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"word-list\",children:[availableWords.map(word=>/*#__PURE__*/_jsx(\"div\",{className:\"word-item \".concat((selectedWord===null||selectedWord===void 0?void 0:selectedWord.id)===word.id?\"selected\":\"\",\" \").concat((animatingMatch===null||animatingMatch===void 0?void 0:animatingMatch.wordId)===word.id?\"connecting\":\"\",\" \").concat((incorrectMatch===null||incorrectMatch===void 0?void 0:incorrectMatch.wordId)===word.id?\"incorrect-flash\":\"\"),onClick:()=>handleWordClick(word),children:word.word},word.id)),availableWords.length===0&&!animatingMatch&&/*#__PURE__*/_jsx(\"div\",{className:\"completion-message\",children:\"\\uD83C\\uDF89 All words matched! Great job!\"})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"definition-list\",children:[availableDefinitions.map((definition,index)=>/*#__PURE__*/_jsx(\"div\",{className:\"definition-item \".concat(selectedDefinition===definition?\"selected\":\"\",\" \").concat((animatingMatch===null||animatingMatch===void 0?void 0:animatingMatch.definition)===definition?\"connecting\":\"\",\" \").concat((incorrectMatch===null||incorrectMatch===void 0?void 0:incorrectMatch.definition)===definition?\"incorrect-flash\":\"\"),onClick:()=>handleDefinitionClick(definition),children:definition},index)),availableDefinitions.length===0&&!animatingMatch&&/*#__PURE__*/_jsx(\"div\",{className:\"completion-message\",children:\"\\uD83C\\uDF89 All definitions matched! Excellent work!\"})]})]});};export default DefinitionMatch;","map":{"version":3,"names":["React","useState","useEffect","useRef","jsx","_jsx","jsxs","_jsxs","DefinitionMatch","_ref","words","onAnswer","selectedWord","setSelectedWord","selectedDefinition","setSelectedDefinition","matchedPairs","setMatchedPairs","Set","shuffledDefinitions","setShuffledDefinitions","animatingMatch","setAnimatingMatch","incorrectMatch","setIncorrectMatch","attemptInProgress","setAttemptInProgress","lastAttemptTimeRef","definitions","map","word","definition","sort","Math","random","current","makeAttempt","now","Date","isCorrect","wordId","id","setTimeout","prev","newSet","add","handleWordClick","has","handleDefinitionClick","availableWords","filter","availableDefinitions","wordWithDefinition","find","className","children","concat","onClick","length","index"],"sources":["/Users/kseniia/Desktop/WillPsGn/src/components/DefinitionMatch.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport { Word } from \"../types/game\";\n\ninterface DefinitionMatchProps {\n  words: Word[];\n  onAnswer: (isCorrect: boolean) => void;\n}\n\nconst DefinitionMatch: React.FC<DefinitionMatchProps> = ({\n  words,\n  onAnswer,\n}) => {\n  const [selectedWord, setSelectedWord] = useState<Word | null>(null);\n  const [selectedDefinition, setSelectedDefinition] = useState<string | null>(\n    null\n  );\n  const [matchedPairs, setMatchedPairs] = useState<Set<number>>(new Set());\n  const [shuffledDefinitions, setShuffledDefinitions] = useState<string[]>([]);\n  const [animatingMatch, setAnimatingMatch] = useState<{\n    wordId: number;\n    definition: string;\n  } | null>(null);\n  const [incorrectMatch, setIncorrectMatch] = useState<{\n    wordId: number;\n    definition: string;\n  } | null>(null);\n  const [attemptInProgress, setAttemptInProgress] = useState<boolean>(false);\n  const lastAttemptTimeRef = useRef<number>(0);\n\n  useEffect(() => {\n    // Shuffle definitions when component mounts or words change\n    const definitions = words.map((word) => word.definition);\n    setShuffledDefinitions([...definitions].sort(() => Math.random() - 0.5));\n\n    // Clear processed attempts when words change (fresh start for each exercise)\n    lastAttemptTimeRef.current = 0;\n  }, [words]);\n\n  const makeAttempt = (word: Word, definition: string) => {\n    if (attemptInProgress) {\n      return;\n    }\n\n    // Simple time-based debounce - prevent attempts within 100ms of each other\n    const now = Date.now();\n    if (now - lastAttemptTimeRef.current < 100) {\n      return;\n    }\n\n    setAttemptInProgress(true);\n    lastAttemptTimeRef.current = now;\n\n    // Clear selections immediately to prevent double-calls\n    setSelectedWord(null);\n    setSelectedDefinition(null);\n\n    const isCorrect = word.definition === definition;\n\n    // Call onAnswer only once per attempt\n    onAnswer(isCorrect);\n\n    if (isCorrect) {\n      // Start connection animation\n      setAnimatingMatch({ wordId: word.id, definition });\n\n      // After animation, add to matched pairs\n      setTimeout(() => {\n        setMatchedPairs((prev) => {\n          const newSet = new Set(prev);\n          newSet.add(word.id);\n          return newSet;\n        });\n        setAnimatingMatch(null);\n        setAttemptInProgress(false);\n      }, 1200); // Animation duration\n    } else {\n      // Show incorrect match animation\n      setIncorrectMatch({ wordId: word.id, definition });\n\n      // After showing red feedback, clear it\n      setTimeout(() => {\n        setIncorrectMatch(null);\n        setAttemptInProgress(false);\n      }, 800); // Shorter duration for incorrect feedback\n    }\n  };\n\n  const handleWordClick = (word: Word) => {\n    if (matchedPairs.has(word.id) || animatingMatch || incorrectMatch) {\n      return;\n    }\n\n    if (selectedDefinition) {\n      // We have a definition selected, make the attempt\n      makeAttempt(word, selectedDefinition);\n    } else {\n      // Just select the word\n      setSelectedWord(word);\n      setSelectedDefinition(null);\n    }\n  };\n\n  const handleDefinitionClick = (definition: string) => {\n    if (animatingMatch || incorrectMatch) {\n      return; // Prevent clicks during animation\n    }\n\n    if (selectedWord) {\n      // We have a word selected, make the attempt\n      makeAttempt(selectedWord, definition);\n    } else {\n      // Just select the definition\n      setSelectedDefinition(definition);\n      setSelectedWord(null);\n    }\n  };\n\n  // Filter out matched words and definitions\n  const availableWords = words.filter((word) => !matchedPairs.has(word.id));\n  const availableDefinitions = shuffledDefinitions.filter((definition) => {\n    // Find the word that has this definition\n    const wordWithDefinition = words.find(\n      (word) => word.definition === definition\n    );\n    return wordWithDefinition && !matchedPairs.has(wordWithDefinition.id);\n  });\n\n  return (\n    <div className=\"match-container\">\n      <div className=\"word-list\">\n        {availableWords.map((word) => (\n          <div\n            key={word.id}\n            className={`word-item ${\n              selectedWord?.id === word.id ? \"selected\" : \"\"\n            } ${animatingMatch?.wordId === word.id ? \"connecting\" : \"\"} ${\n              incorrectMatch?.wordId === word.id ? \"incorrect-flash\" : \"\"\n            }`}\n            onClick={() => handleWordClick(word)}\n          >\n            {word.word}\n          </div>\n        ))}\n        {availableWords.length === 0 && !animatingMatch && (\n          <div className=\"completion-message\">\n            ðŸŽ‰ All words matched! Great job!\n          </div>\n        )}\n      </div>\n\n      <div className=\"definition-list\">\n        {availableDefinitions.map((definition, index) => (\n          <div\n            key={index}\n            className={`definition-item ${\n              selectedDefinition === definition ? \"selected\" : \"\"\n            } ${\n              animatingMatch?.definition === definition ? \"connecting\" : \"\"\n            } ${\n              incorrectMatch?.definition === definition ? \"incorrect-flash\" : \"\"\n            }`}\n            onClick={() => handleDefinitionClick(definition)}\n          >\n            {definition}\n          </div>\n        ))}\n        {availableDefinitions.length === 0 && !animatingMatch && (\n          <div className=\"completion-message\">\n            ðŸŽ‰ All definitions matched! Excellent work!\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default DefinitionMatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}