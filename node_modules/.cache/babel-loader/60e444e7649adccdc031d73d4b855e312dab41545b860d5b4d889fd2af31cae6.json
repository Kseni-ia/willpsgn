{"ast":null,"code":"var _jsxFileName = \"/Users/kseniia/Desktop/WillPsGn/src/components/DefinitionMatch.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DefinitionMatch = ({\n  words,\n  onAnswer\n}) => {\n  _s();\n  const [selectedWord, setSelectedWord] = useState(null);\n  const [selectedDefinition, setSelectedDefinition] = useState(null);\n  const [matchedPairs, setMatchedPairs] = useState(new Set());\n  const [shuffledDefinitions, setShuffledDefinitions] = useState([]);\n  const [animatingMatch, setAnimatingMatch] = useState(null);\n  const [incorrectMatch, setIncorrectMatch] = useState(null);\n  const [attemptInProgress, setAttemptInProgress] = useState(false);\n  const lastAttemptTimeRef = useRef(0);\n  useEffect(() => {\n    // Shuffle definitions when component mounts or words change\n    const definitions = words.map(word => word.definition);\n    setShuffledDefinitions([...definitions].sort(() => Math.random() - 0.5));\n\n    // Clear processed attempts when words change (fresh start for each exercise)\n    lastAttemptTimeRef.current = 0;\n  }, [words]);\n  const makeAttempt = (word, definition) => {\n    console.log(`makeAttempt called: attemptInProgress=${attemptInProgress}`);\n    if (attemptInProgress) {\n      console.log(\"Attempt already in progress, ignoring...\");\n      return;\n    }\n\n    // Simple time-based debounce - prevent attempts within 100ms of each other\n    const now = Date.now();\n    if (now - lastAttemptTimeRef.current < 100) {\n      console.log(\"Attempt too soon after last attempt, ignoring...\");\n      return;\n    }\n    console.log(`Processing new attempt at time: ${now}`);\n    setAttemptInProgress(true);\n    lastAttemptTimeRef.current = now;\n\n    // Clear selections immediately to prevent double-calls\n    setSelectedWord(null);\n    setSelectedDefinition(null);\n    const isCorrect = word.definition === definition;\n    console.log(`Attempt result: ${isCorrect ? \"CORRECT\" : \"INCORRECT\"}`);\n\n    // Call onAnswer only once per attempt\n    console.log(`Calling onAnswer(${isCorrect})`);\n    onAnswer(isCorrect);\n    if (isCorrect) {\n      // Start connection animation\n      setAnimatingMatch({\n        wordId: word.id,\n        definition\n      });\n\n      // After animation, add to matched pairs\n      setTimeout(() => {\n        setMatchedPairs(prev => {\n          const newSet = new Set(prev);\n          newSet.add(word.id);\n          return newSet;\n        });\n        setAnimatingMatch(null);\n        setAttemptInProgress(false);\n        console.log(\"Correct attempt completed, resetting flags\");\n      }, 1200); // Animation duration\n    } else {\n      // Show incorrect match animation\n      setIncorrectMatch({\n        wordId: word.id,\n        definition\n      });\n\n      // After showing red feedback, clear it\n      setTimeout(() => {\n        setIncorrectMatch(null);\n        setAttemptInProgress(false);\n        console.log(\"Incorrect attempt completed, resetting flags\");\n      }, 800); // Shorter duration for incorrect feedback\n    }\n  };\n  const handleWordClick = word => {\n    console.log(`Word clicked: ${word.word}`);\n    console.log(`Current state: matchedPairs=${matchedPairs.has(word.id)}, animatingMatch=${!!animatingMatch}, incorrectMatch=${!!incorrectMatch}`);\n    if (matchedPairs.has(word.id) || animatingMatch || incorrectMatch) {\n      console.log(\"Word click ignored due to state\");\n      return;\n    }\n    console.log(`selectedDefinition: ${selectedDefinition ? \"exists\" : \"null\"}`);\n    if (selectedDefinition) {\n      // We have a definition selected, make the attempt\n      console.log(`Making attempt: ${word.word} + definition`);\n      makeAttempt(word, selectedDefinition);\n    } else {\n      // Just select the word\n      console.log(`Selecting word: ${word.word}`);\n      setSelectedWord(word);\n      setSelectedDefinition(null);\n    }\n  };\n  const handleDefinitionClick = definition => {\n    console.log(`Definition clicked: ${definition.substring(0, 30)}...`);\n    console.log(`Current state: animatingMatch=${!!animatingMatch}, incorrectMatch=${!!incorrectMatch}`);\n    if (animatingMatch || incorrectMatch) {\n      console.log(\"Definition click ignored due to animation/incorrect state\");\n      return; // Prevent clicks during animation\n    }\n    console.log(`selectedWord: ${selectedWord ? selectedWord.word : \"null\"}`);\n    if (selectedWord) {\n      // We have a word selected, make the attempt\n      console.log(`Making attempt: ${selectedWord.word} + definition`);\n      makeAttempt(selectedWord, definition);\n    } else {\n      // Just select the definition\n      console.log(`Selecting definition: ${definition.substring(0, 30)}...`);\n      setSelectedDefinition(definition);\n      setSelectedWord(null);\n    }\n  };\n\n  // Filter out matched words and definitions\n  const availableWords = words.filter(word => !matchedPairs.has(word.id));\n  const availableDefinitions = shuffledDefinitions.filter(definition => {\n    // Find the word that has this definition\n    const wordWithDefinition = words.find(word => word.definition === definition);\n    return wordWithDefinition && !matchedPairs.has(wordWithDefinition.id);\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"match-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"word-list\",\n      children: [availableWords.map(word => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `word-item ${(selectedWord === null || selectedWord === void 0 ? void 0 : selectedWord.id) === word.id ? \"selected\" : \"\"} ${(animatingMatch === null || animatingMatch === void 0 ? void 0 : animatingMatch.wordId) === word.id ? \"connecting\" : \"\"} ${(incorrectMatch === null || incorrectMatch === void 0 ? void 0 : incorrectMatch.wordId) === word.id ? \"incorrect-flash\" : \"\"}`,\n        onClick: () => handleWordClick(word),\n        children: word.word\n      }, word.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 11\n      }, this)), availableWords.length === 0 && !animatingMatch && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"completion-message\",\n        children: \"\\uD83C\\uDF89 All words matched! Great job!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 178,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"definition-list\",\n      children: [availableDefinitions.map((definition, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `definition-item ${selectedDefinition === definition ? \"selected\" : \"\"} ${(animatingMatch === null || animatingMatch === void 0 ? void 0 : animatingMatch.definition) === definition ? \"connecting\" : \"\"} ${(incorrectMatch === null || incorrectMatch === void 0 ? void 0 : incorrectMatch.definition) === definition ? \"incorrect-flash\" : \"\"}`,\n        onClick: () => handleDefinitionClick(definition),\n        children: definition\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 186,\n        columnNumber: 11\n      }, this)), availableDefinitions.length === 0 && !animatingMatch && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"completion-message\",\n        children: \"\\uD83C\\uDF89 All definitions matched! Excellent work!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 201,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 162,\n    columnNumber: 5\n  }, this);\n};\n_s(DefinitionMatch, \"n5NqE9F89MQIOog1hdjKUhV+4sY=\");\n_c = DefinitionMatch;\nexport default DefinitionMatch;\nvar _c;\n$RefreshReg$(_c, \"DefinitionMatch\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","DefinitionMatch","words","onAnswer","_s","selectedWord","setSelectedWord","selectedDefinition","setSelectedDefinition","matchedPairs","setMatchedPairs","Set","shuffledDefinitions","setShuffledDefinitions","animatingMatch","setAnimatingMatch","incorrectMatch","setIncorrectMatch","attemptInProgress","setAttemptInProgress","lastAttemptTimeRef","definitions","map","word","definition","sort","Math","random","current","makeAttempt","console","log","now","Date","isCorrect","wordId","id","setTimeout","prev","newSet","add","handleWordClick","has","handleDefinitionClick","substring","availableWords","filter","availableDefinitions","wordWithDefinition","find","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","length","index","_c","$RefreshReg$"],"sources":["/Users/kseniia/Desktop/WillPsGn/src/components/DefinitionMatch.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport { Word } from \"../types/game\";\n\ninterface DefinitionMatchProps {\n  words: Word[];\n  onAnswer: (isCorrect: boolean) => void;\n}\n\nconst DefinitionMatch: React.FC<DefinitionMatchProps> = ({\n  words,\n  onAnswer,\n}) => {\n  const [selectedWord, setSelectedWord] = useState<Word | null>(null);\n  const [selectedDefinition, setSelectedDefinition] = useState<string | null>(\n    null\n  );\n  const [matchedPairs, setMatchedPairs] = useState<Set<number>>(new Set());\n  const [shuffledDefinitions, setShuffledDefinitions] = useState<string[]>([]);\n  const [animatingMatch, setAnimatingMatch] = useState<{\n    wordId: number;\n    definition: string;\n  } | null>(null);\n  const [incorrectMatch, setIncorrectMatch] = useState<{\n    wordId: number;\n    definition: string;\n  } | null>(null);\n  const [attemptInProgress, setAttemptInProgress] = useState<boolean>(false);\n  const lastAttemptTimeRef = useRef<number>(0);\n\n  useEffect(() => {\n    // Shuffle definitions when component mounts or words change\n    const definitions = words.map((word) => word.definition);\n    setShuffledDefinitions([...definitions].sort(() => Math.random() - 0.5));\n\n    // Clear processed attempts when words change (fresh start for each exercise)\n    lastAttemptTimeRef.current = 0;\n  }, [words]);\n\n  const makeAttempt = (word: Word, definition: string) => {\n    console.log(`makeAttempt called: attemptInProgress=${attemptInProgress}`);\n\n    if (attemptInProgress) {\n      console.log(\"Attempt already in progress, ignoring...\");\n      return;\n    }\n\n    // Simple time-based debounce - prevent attempts within 100ms of each other\n    const now = Date.now();\n    if (now - lastAttemptTimeRef.current < 100) {\n      console.log(\"Attempt too soon after last attempt, ignoring...\");\n      return;\n    }\n\n    console.log(`Processing new attempt at time: ${now}`);\n    setAttemptInProgress(true);\n    lastAttemptTimeRef.current = now;\n\n    // Clear selections immediately to prevent double-calls\n    setSelectedWord(null);\n    setSelectedDefinition(null);\n\n    const isCorrect = word.definition === definition;\n    console.log(`Attempt result: ${isCorrect ? \"CORRECT\" : \"INCORRECT\"}`);\n\n    // Call onAnswer only once per attempt\n    console.log(`Calling onAnswer(${isCorrect})`);\n    onAnswer(isCorrect);\n\n    if (isCorrect) {\n      // Start connection animation\n      setAnimatingMatch({ wordId: word.id, definition });\n\n      // After animation, add to matched pairs\n      setTimeout(() => {\n        setMatchedPairs((prev) => {\n          const newSet = new Set(prev);\n          newSet.add(word.id);\n          return newSet;\n        });\n        setAnimatingMatch(null);\n        setAttemptInProgress(false);\n        console.log(\"Correct attempt completed, resetting flags\");\n      }, 1200); // Animation duration\n    } else {\n      // Show incorrect match animation\n      setIncorrectMatch({ wordId: word.id, definition });\n\n      // After showing red feedback, clear it\n      setTimeout(() => {\n        setIncorrectMatch(null);\n        setAttemptInProgress(false);\n        console.log(\"Incorrect attempt completed, resetting flags\");\n      }, 800); // Shorter duration for incorrect feedback\n    }\n  };\n\n  const handleWordClick = (word: Word) => {\n    console.log(`Word clicked: ${word.word}`);\n    console.log(\n      `Current state: matchedPairs=${matchedPairs.has(\n        word.id\n      )}, animatingMatch=${!!animatingMatch}, incorrectMatch=${!!incorrectMatch}`\n    );\n\n    if (matchedPairs.has(word.id) || animatingMatch || incorrectMatch) {\n      console.log(\"Word click ignored due to state\");\n      return;\n    }\n\n    console.log(\n      `selectedDefinition: ${selectedDefinition ? \"exists\" : \"null\"}`\n    );\n\n    if (selectedDefinition) {\n      // We have a definition selected, make the attempt\n      console.log(`Making attempt: ${word.word} + definition`);\n      makeAttempt(word, selectedDefinition);\n    } else {\n      // Just select the word\n      console.log(`Selecting word: ${word.word}`);\n      setSelectedWord(word);\n      setSelectedDefinition(null);\n    }\n  };\n\n  const handleDefinitionClick = (definition: string) => {\n    console.log(`Definition clicked: ${definition.substring(0, 30)}...`);\n    console.log(\n      `Current state: animatingMatch=${!!animatingMatch}, incorrectMatch=${!!incorrectMatch}`\n    );\n\n    if (animatingMatch || incorrectMatch) {\n      console.log(\"Definition click ignored due to animation/incorrect state\");\n      return; // Prevent clicks during animation\n    }\n\n    console.log(`selectedWord: ${selectedWord ? selectedWord.word : \"null\"}`);\n\n    if (selectedWord) {\n      // We have a word selected, make the attempt\n      console.log(`Making attempt: ${selectedWord.word} + definition`);\n      makeAttempt(selectedWord, definition);\n    } else {\n      // Just select the definition\n      console.log(`Selecting definition: ${definition.substring(0, 30)}...`);\n      setSelectedDefinition(definition);\n      setSelectedWord(null);\n    }\n  };\n\n  // Filter out matched words and definitions\n  const availableWords = words.filter((word) => !matchedPairs.has(word.id));\n  const availableDefinitions = shuffledDefinitions.filter((definition) => {\n    // Find the word that has this definition\n    const wordWithDefinition = words.find(\n      (word) => word.definition === definition\n    );\n    return wordWithDefinition && !matchedPairs.has(wordWithDefinition.id);\n  });\n\n  return (\n    <div className=\"match-container\">\n      <div className=\"word-list\">\n        {availableWords.map((word) => (\n          <div\n            key={word.id}\n            className={`word-item ${\n              selectedWord?.id === word.id ? \"selected\" : \"\"\n            } ${animatingMatch?.wordId === word.id ? \"connecting\" : \"\"} ${\n              incorrectMatch?.wordId === word.id ? \"incorrect-flash\" : \"\"\n            }`}\n            onClick={() => handleWordClick(word)}\n          >\n            {word.word}\n          </div>\n        ))}\n        {availableWords.length === 0 && !animatingMatch && (\n          <div className=\"completion-message\">\n            🎉 All words matched! Great job!\n          </div>\n        )}\n      </div>\n\n      <div className=\"definition-list\">\n        {availableDefinitions.map((definition, index) => (\n          <div\n            key={index}\n            className={`definition-item ${\n              selectedDefinition === definition ? \"selected\" : \"\"\n            } ${\n              animatingMatch?.definition === definition ? \"connecting\" : \"\"\n            } ${\n              incorrectMatch?.definition === definition ? \"incorrect-flash\" : \"\"\n            }`}\n            onClick={() => handleDefinitionClick(definition)}\n          >\n            {definition}\n          </div>\n        ))}\n        {availableDefinitions.length === 0 && !animatingMatch && (\n          <div className=\"completion-message\">\n            🎉 All definitions matched! Excellent work!\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default DefinitionMatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}