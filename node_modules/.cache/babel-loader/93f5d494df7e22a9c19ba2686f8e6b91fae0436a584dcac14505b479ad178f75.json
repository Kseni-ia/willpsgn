{"ast":null,"code":"var _jsxFileName = \"/Users/kseniia/Desktop/WillPsGn/src/components/MemoryGame.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MemoryGame = ({\n  words,\n  onAnswer\n}) => {\n  _s();\n  const [cards, setCards] = useState([]);\n  const [flippedCards, setFlippedCards] = useState([]);\n  const [gameStarted, setGameStarted] = useState(false);\n  const [gameCompleted, setGameCompleted] = useState(false);\n\n  // Fisher-Yates shuffle algorithm for proper randomization\n  const shuffleArray = array => {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  };\n\n  // Check if game is completed\n  useEffect(() => {\n    if (cards.length > 0 && cards.every(card => card.isMatched)) {\n      setGameCompleted(true);\n    }\n  }, [cards]);\n  useEffect(() => {\n    // Create cards from words and their synonyms\n    const newCards = [];\n    words.forEach(word => {\n      // Add the vocabulary word\n      newCards.push({\n        id: word.id,\n        content: word.word,\n        type: \"word\",\n        isFlipped: false,\n        isMatched: false\n      });\n\n      // Add a random synonym for each word (re-randomized each game)\n      const shuffledSynonyms = shuffleArray([...word.synonyms]);\n      const randomSynonym = shuffledSynonyms[0];\n      newCards.push({\n        id: word.id,\n        content: randomSynonym,\n        type: \"synonym\",\n        isFlipped: false,\n        isMatched: false\n      });\n    });\n\n    // Properly shuffle the cards using Fisher-Yates algorithm\n    setCards(shuffleArray(newCards));\n\n    // Reset game state\n    setGameStarted(false);\n    setGameCompleted(false);\n    setFlippedCards([]);\n  }, [words]);\n  const handleCardClick = index => {\n    // Start the game on first click\n    if (!gameStarted) {\n      setGameStarted(true);\n    }\n    if (flippedCards.length === 2 || cards[index].isMatched || flippedCards.includes(index)) {\n      return;\n    }\n    const newFlippedCards = [...flippedCards, index];\n    setFlippedCards(newFlippedCards);\n\n    // Update card flip state\n    setCards(prevCards => {\n      const newCards = [...prevCards];\n      newCards[index] = {\n        ...newCards[index],\n        isFlipped: true\n      };\n      return newCards;\n    });\n\n    // Check for match if two cards are flipped\n    if (newFlippedCards.length === 2) {\n      const [firstIndex, secondIndex] = newFlippedCards;\n      const firstCard = cards[firstIndex];\n      const secondCard = cards[secondIndex];\n      setTimeout(() => {\n        if (firstCard.id === secondCard.id) {\n          // Match found - keep cards flipped and mark as matched\n          onAnswer(true);\n          setCards(prevCards => {\n            const newCards = [...prevCards];\n            newCards[firstIndex] = {\n              ...newCards[firstIndex],\n              isMatched: true,\n              isFlipped: true\n            };\n            newCards[secondIndex] = {\n              ...newCards[secondIndex],\n              isMatched: true,\n              isFlipped: true\n            };\n            return newCards;\n          });\n        } else {\n          // No match - flip cards back\n          onAnswer(false);\n          setCards(prevCards => {\n            const newCards = [...prevCards];\n            newCards[firstIndex] = {\n              ...newCards[firstIndex],\n              isFlipped: false\n            };\n            newCards[secondIndex] = {\n              ...newCards[secondIndex],\n              isFlipped: false\n            };\n            return newCards;\n          });\n        }\n        setFlippedCards([]);\n      }, 800);\n    }\n  };\n  const restartGame = () => {\n    // Re-create and shuffle cards with new random synonyms\n    const newCards = [];\n    words.forEach(word => {\n      // Add the vocabulary word\n      newCards.push({\n        id: word.id,\n        content: word.word,\n        type: \"word\",\n        isFlipped: false,\n        isMatched: false\n      });\n\n      // Add a different random synonym for variety\n      const shuffledSynonyms = shuffleArray([...word.synonyms]);\n      const randomSynonym = shuffledSynonyms[0];\n      newCards.push({\n        id: word.id,\n        content: randomSynonym,\n        type: \"synonym\",\n        isFlipped: false,\n        isMatched: false\n      });\n    });\n\n    // Properly shuffle the cards using Fisher-Yates algorithm\n    setCards(shuffleArray(newCards));\n    setGameStarted(false);\n    setGameCompleted(false);\n    setFlippedCards([]);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"memory-game\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-header\",\n      children: [gameCompleted && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-completed\",\n        children: [\"\\uD83C\\uDF89 Game Completed! Great job matching all pairs!\", /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"restart-btn\",\n          onClick: restartGame,\n          children: \"Play Again\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 185,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 11\n      }, this), !gameStarted && !gameCompleted && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-instruction\",\n        children: \"Click any card to start!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 192,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"cards-grid\",\n      children: cards.map((card, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `card ${card.isFlipped ? \"flipped\" : \"\"} ${card.isMatched ? \"matched\" : \"\"} ${card.type === \"word\" ? \"word-card\" : \"synonym-card\"}`,\n        onClick: () => handleCardClick(index),\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"card-inner\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"card-front\",\n            children: \"?\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 206,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"card-back\",\n            children: card.content\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 207,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 205,\n          columnNumber: 13\n        }, this)\n      }, `${card.type}-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 198,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 196,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 180,\n    columnNumber: 5\n  }, this);\n};\n_s(MemoryGame, \"hrEB/9Mt16TosNxnqKZR8lFHJpc=\");\n_c = MemoryGame;\nexport default MemoryGame;\nvar _c;\n$RefreshReg$(_c, \"MemoryGame\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","MemoryGame","words","onAnswer","_s","cards","setCards","flippedCards","setFlippedCards","gameStarted","setGameStarted","gameCompleted","setGameCompleted","shuffleArray","array","shuffled","i","length","j","Math","floor","random","every","card","isMatched","newCards","forEach","word","push","id","content","type","isFlipped","shuffledSynonyms","synonyms","randomSynonym","handleCardClick","index","includes","newFlippedCards","prevCards","firstIndex","secondIndex","firstCard","secondCard","setTimeout","restartGame","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","map","_c","$RefreshReg$"],"sources":["/Users/kseniia/Desktop/WillPsGn/src/components/MemoryGame.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { Word } from \"../types/game\";\n\ninterface MemoryGameProps {\n  words: Word[];\n  onAnswer: (isCorrect: boolean) => void;\n}\n\ninterface Card {\n  id: number;\n  content: string;\n  type: \"word\" | \"synonym\";\n  isFlipped: boolean;\n  isMatched: boolean;\n}\n\nconst MemoryGame: React.FC<MemoryGameProps> = ({ words, onAnswer }) => {\n  const [cards, setCards] = useState<Card[]>([]);\n  const [flippedCards, setFlippedCards] = useState<number[]>([]);\n  const [gameStarted, setGameStarted] = useState(false);\n  const [gameCompleted, setGameCompleted] = useState(false);\n\n  // Fisher-Yates shuffle algorithm for proper randomization\n  const shuffleArray = <T,>(array: T[]): T[] => {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  };\n\n  // Check if game is completed\n  useEffect(() => {\n    if (cards.length > 0 && cards.every((card) => card.isMatched)) {\n      setGameCompleted(true);\n    }\n  }, [cards]);\n\n  useEffect(() => {\n    // Create cards from words and their synonyms\n    const newCards: Card[] = [];\n\n    words.forEach((word) => {\n      // Add the vocabulary word\n      newCards.push({\n        id: word.id,\n        content: word.word,\n        type: \"word\",\n        isFlipped: false,\n        isMatched: false,\n      });\n\n      // Add a random synonym for each word (re-randomized each game)\n      const shuffledSynonyms = shuffleArray([...word.synonyms]);\n      const randomSynonym = shuffledSynonyms[0];\n      newCards.push({\n        id: word.id,\n        content: randomSynonym,\n        type: \"synonym\",\n        isFlipped: false,\n        isMatched: false,\n      });\n    });\n\n    // Properly shuffle the cards using Fisher-Yates algorithm\n    setCards(shuffleArray(newCards));\n\n    // Reset game state\n    setGameStarted(false);\n    setGameCompleted(false);\n    setFlippedCards([]);\n  }, [words]);\n\n  const handleCardClick = (index: number) => {\n    // Start the game on first click\n    if (!gameStarted) {\n      setGameStarted(true);\n    }\n\n    if (\n      flippedCards.length === 2 ||\n      cards[index].isMatched ||\n      flippedCards.includes(index)\n    ) {\n      return;\n    }\n\n    const newFlippedCards = [...flippedCards, index];\n    setFlippedCards(newFlippedCards);\n\n    // Update card flip state\n    setCards((prevCards) => {\n      const newCards = [...prevCards];\n      newCards[index] = { ...newCards[index], isFlipped: true };\n      return newCards;\n    });\n\n    // Check for match if two cards are flipped\n    if (newFlippedCards.length === 2) {\n      const [firstIndex, secondIndex] = newFlippedCards;\n      const firstCard = cards[firstIndex];\n      const secondCard = cards[secondIndex];\n\n      setTimeout(() => {\n        if (firstCard.id === secondCard.id) {\n          // Match found - keep cards flipped and mark as matched\n          onAnswer(true);\n\n          setCards((prevCards) => {\n            const newCards = [...prevCards];\n            newCards[firstIndex] = {\n              ...newCards[firstIndex],\n              isMatched: true,\n              isFlipped: true,\n            };\n            newCards[secondIndex] = {\n              ...newCards[secondIndex],\n              isMatched: true,\n              isFlipped: true,\n            };\n            return newCards;\n          });\n        } else {\n          // No match - flip cards back\n          onAnswer(false);\n          setCards((prevCards) => {\n            const newCards = [...prevCards];\n            newCards[firstIndex] = {\n              ...newCards[firstIndex],\n              isFlipped: false,\n            };\n            newCards[secondIndex] = {\n              ...newCards[secondIndex],\n              isFlipped: false,\n            };\n            return newCards;\n          });\n        }\n        setFlippedCards([]);\n      }, 800);\n    }\n  };\n\n  const restartGame = () => {\n    // Re-create and shuffle cards with new random synonyms\n    const newCards: Card[] = [];\n\n    words.forEach((word) => {\n      // Add the vocabulary word\n      newCards.push({\n        id: word.id,\n        content: word.word,\n        type: \"word\",\n        isFlipped: false,\n        isMatched: false,\n      });\n\n      // Add a different random synonym for variety\n      const shuffledSynonyms = shuffleArray([...word.synonyms]);\n      const randomSynonym = shuffledSynonyms[0];\n      newCards.push({\n        id: word.id,\n        content: randomSynonym,\n        type: \"synonym\",\n        isFlipped: false,\n        isMatched: false,\n      });\n    });\n\n    // Properly shuffle the cards using Fisher-Yates algorithm\n    setCards(shuffleArray(newCards));\n\n    setGameStarted(false);\n    setGameCompleted(false);\n    setFlippedCards([]);\n  };\n\n  return (\n    <div className=\"memory-game\">\n      <div className=\"game-header\">\n        {gameCompleted && (\n          <div className=\"game-completed\">\n            ðŸŽ‰ Game Completed! Great job matching all pairs!\n            <button className=\"restart-btn\" onClick={restartGame}>\n              Play Again\n            </button>\n          </div>\n        )}\n\n        {!gameStarted && !gameCompleted && (\n          <div className=\"game-instruction\">Click any card to start!</div>\n        )}\n      </div>\n\n      <div className=\"cards-grid\">\n        {cards.map((card, index) => (\n          <div\n            key={`${card.type}-${index}`}\n            className={`card ${card.isFlipped ? \"flipped\" : \"\"} ${\n              card.isMatched ? \"matched\" : \"\"\n            } ${card.type === \"word\" ? \"word-card\" : \"synonym-card\"}`}\n            onClick={() => handleCardClick(index)}\n          >\n            <div className=\"card-inner\">\n              <div className=\"card-front\">?</div>\n              <div className=\"card-back\">{card.content}</div>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default MemoryGame;\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAgBnD,MAAMC,UAAqC,GAAGA,CAAC;EAAEC,KAAK;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EACrE,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGT,QAAQ,CAAS,EAAE,CAAC;EAC9C,MAAM,CAACU,YAAY,EAAEC,eAAe,CAAC,GAAGX,QAAQ,CAAW,EAAE,CAAC;EAC9D,MAAM,CAACY,WAAW,EAAEC,cAAc,CAAC,GAAGb,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACc,aAAa,EAAEC,gBAAgB,CAAC,GAAGf,QAAQ,CAAC,KAAK,CAAC;;EAEzD;EACA,MAAMgB,YAAY,GAAQC,KAAU,IAAU;IAC5C,MAAMC,QAAQ,GAAG,CAAC,GAAGD,KAAK,CAAC;IAC3B,KAAK,IAAIE,CAAC,GAAGD,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC5C,MAAME,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIL,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7C,CAACD,QAAQ,CAACC,CAAC,CAAC,EAAED,QAAQ,CAACG,CAAC,CAAC,CAAC,GAAG,CAACH,QAAQ,CAACG,CAAC,CAAC,EAAEH,QAAQ,CAACC,CAAC,CAAC,CAAC;IACzD;IACA,OAAOD,QAAQ;EACjB,CAAC;;EAED;EACAjB,SAAS,CAAC,MAAM;IACd,IAAIO,KAAK,CAACY,MAAM,GAAG,CAAC,IAAIZ,KAAK,CAACiB,KAAK,CAAEC,IAAI,IAAKA,IAAI,CAACC,SAAS,CAAC,EAAE;MAC7DZ,gBAAgB,CAAC,IAAI,CAAC;IACxB;EACF,CAAC,EAAE,CAACP,KAAK,CAAC,CAAC;EAEXP,SAAS,CAAC,MAAM;IACd;IACA,MAAM2B,QAAgB,GAAG,EAAE;IAE3BvB,KAAK,CAACwB,OAAO,CAAEC,IAAI,IAAK;MACtB;MACAF,QAAQ,CAACG,IAAI,CAAC;QACZC,EAAE,EAAEF,IAAI,CAACE,EAAE;QACXC,OAAO,EAAEH,IAAI,CAACA,IAAI;QAClBI,IAAI,EAAE,MAAM;QACZC,SAAS,EAAE,KAAK;QAChBR,SAAS,EAAE;MACb,CAAC,CAAC;;MAEF;MACA,MAAMS,gBAAgB,GAAGpB,YAAY,CAAC,CAAC,GAAGc,IAAI,CAACO,QAAQ,CAAC,CAAC;MACzD,MAAMC,aAAa,GAAGF,gBAAgB,CAAC,CAAC,CAAC;MACzCR,QAAQ,CAACG,IAAI,CAAC;QACZC,EAAE,EAAEF,IAAI,CAACE,EAAE;QACXC,OAAO,EAAEK,aAAa;QACtBJ,IAAI,EAAE,SAAS;QACfC,SAAS,EAAE,KAAK;QAChBR,SAAS,EAAE;MACb,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACAlB,QAAQ,CAACO,YAAY,CAACY,QAAQ,CAAC,CAAC;;IAEhC;IACAf,cAAc,CAAC,KAAK,CAAC;IACrBE,gBAAgB,CAAC,KAAK,CAAC;IACvBJ,eAAe,CAAC,EAAE,CAAC;EACrB,CAAC,EAAE,CAACN,KAAK,CAAC,CAAC;EAEX,MAAMkC,eAAe,GAAIC,KAAa,IAAK;IACzC;IACA,IAAI,CAAC5B,WAAW,EAAE;MAChBC,cAAc,CAAC,IAAI,CAAC;IACtB;IAEA,IACEH,YAAY,CAACU,MAAM,KAAK,CAAC,IACzBZ,KAAK,CAACgC,KAAK,CAAC,CAACb,SAAS,IACtBjB,YAAY,CAAC+B,QAAQ,CAACD,KAAK,CAAC,EAC5B;MACA;IACF;IAEA,MAAME,eAAe,GAAG,CAAC,GAAGhC,YAAY,EAAE8B,KAAK,CAAC;IAChD7B,eAAe,CAAC+B,eAAe,CAAC;;IAEhC;IACAjC,QAAQ,CAAEkC,SAAS,IAAK;MACtB,MAAMf,QAAQ,GAAG,CAAC,GAAGe,SAAS,CAAC;MAC/Bf,QAAQ,CAACY,KAAK,CAAC,GAAG;QAAE,GAAGZ,QAAQ,CAACY,KAAK,CAAC;QAAEL,SAAS,EAAE;MAAK,CAAC;MACzD,OAAOP,QAAQ;IACjB,CAAC,CAAC;;IAEF;IACA,IAAIc,eAAe,CAACtB,MAAM,KAAK,CAAC,EAAE;MAChC,MAAM,CAACwB,UAAU,EAAEC,WAAW,CAAC,GAAGH,eAAe;MACjD,MAAMI,SAAS,GAAGtC,KAAK,CAACoC,UAAU,CAAC;MACnC,MAAMG,UAAU,GAAGvC,KAAK,CAACqC,WAAW,CAAC;MAErCG,UAAU,CAAC,MAAM;QACf,IAAIF,SAAS,CAACd,EAAE,KAAKe,UAAU,CAACf,EAAE,EAAE;UAClC;UACA1B,QAAQ,CAAC,IAAI,CAAC;UAEdG,QAAQ,CAAEkC,SAAS,IAAK;YACtB,MAAMf,QAAQ,GAAG,CAAC,GAAGe,SAAS,CAAC;YAC/Bf,QAAQ,CAACgB,UAAU,CAAC,GAAG;cACrB,GAAGhB,QAAQ,CAACgB,UAAU,CAAC;cACvBjB,SAAS,EAAE,IAAI;cACfQ,SAAS,EAAE;YACb,CAAC;YACDP,QAAQ,CAACiB,WAAW,CAAC,GAAG;cACtB,GAAGjB,QAAQ,CAACiB,WAAW,CAAC;cACxBlB,SAAS,EAAE,IAAI;cACfQ,SAAS,EAAE;YACb,CAAC;YACD,OAAOP,QAAQ;UACjB,CAAC,CAAC;QACJ,CAAC,MAAM;UACL;UACAtB,QAAQ,CAAC,KAAK,CAAC;UACfG,QAAQ,CAAEkC,SAAS,IAAK;YACtB,MAAMf,QAAQ,GAAG,CAAC,GAAGe,SAAS,CAAC;YAC/Bf,QAAQ,CAACgB,UAAU,CAAC,GAAG;cACrB,GAAGhB,QAAQ,CAACgB,UAAU,CAAC;cACvBT,SAAS,EAAE;YACb,CAAC;YACDP,QAAQ,CAACiB,WAAW,CAAC,GAAG;cACtB,GAAGjB,QAAQ,CAACiB,WAAW,CAAC;cACxBV,SAAS,EAAE;YACb,CAAC;YACD,OAAOP,QAAQ;UACjB,CAAC,CAAC;QACJ;QACAjB,eAAe,CAAC,EAAE,CAAC;MACrB,CAAC,EAAE,GAAG,CAAC;IACT;EACF,CAAC;EAED,MAAMsC,WAAW,GAAGA,CAAA,KAAM;IACxB;IACA,MAAMrB,QAAgB,GAAG,EAAE;IAE3BvB,KAAK,CAACwB,OAAO,CAAEC,IAAI,IAAK;MACtB;MACAF,QAAQ,CAACG,IAAI,CAAC;QACZC,EAAE,EAAEF,IAAI,CAACE,EAAE;QACXC,OAAO,EAAEH,IAAI,CAACA,IAAI;QAClBI,IAAI,EAAE,MAAM;QACZC,SAAS,EAAE,KAAK;QAChBR,SAAS,EAAE;MACb,CAAC,CAAC;;MAEF;MACA,MAAMS,gBAAgB,GAAGpB,YAAY,CAAC,CAAC,GAAGc,IAAI,CAACO,QAAQ,CAAC,CAAC;MACzD,MAAMC,aAAa,GAAGF,gBAAgB,CAAC,CAAC,CAAC;MACzCR,QAAQ,CAACG,IAAI,CAAC;QACZC,EAAE,EAAEF,IAAI,CAACE,EAAE;QACXC,OAAO,EAAEK,aAAa;QACtBJ,IAAI,EAAE,SAAS;QACfC,SAAS,EAAE,KAAK;QAChBR,SAAS,EAAE;MACb,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACAlB,QAAQ,CAACO,YAAY,CAACY,QAAQ,CAAC,CAAC;IAEhCf,cAAc,CAAC,KAAK,CAAC;IACrBE,gBAAgB,CAAC,KAAK,CAAC;IACvBJ,eAAe,CAAC,EAAE,CAAC;EACrB,CAAC;EAED,oBACER,OAAA;IAAK+C,SAAS,EAAC,aAAa;IAAAC,QAAA,gBAC1BhD,OAAA;MAAK+C,SAAS,EAAC,aAAa;MAAAC,QAAA,GACzBrC,aAAa,iBACZX,OAAA;QAAK+C,SAAS,EAAC,gBAAgB;QAAAC,QAAA,GAAC,4DAE9B,eAAAhD,OAAA;UAAQ+C,SAAS,EAAC,aAAa;UAACE,OAAO,EAAEH,WAAY;UAAAE,QAAA,EAAC;QAEtD;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACN,CACN,EAEA,CAAC5C,WAAW,IAAI,CAACE,aAAa,iBAC7BX,OAAA;QAAK+C,SAAS,EAAC,kBAAkB;QAAAC,QAAA,EAAC;MAAwB;QAAAE,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAChE;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE,CAAC,eAENrD,OAAA;MAAK+C,SAAS,EAAC,YAAY;MAAAC,QAAA,EACxB3C,KAAK,CAACiD,GAAG,CAAC,CAAC/B,IAAI,EAAEc,KAAK,kBACrBrC,OAAA;QAEE+C,SAAS,EAAE,QAAQxB,IAAI,CAACS,SAAS,GAAG,SAAS,GAAG,EAAE,IAChDT,IAAI,CAACC,SAAS,GAAG,SAAS,GAAG,EAAE,IAC7BD,IAAI,CAACQ,IAAI,KAAK,MAAM,GAAG,WAAW,GAAG,cAAc,EAAG;QAC1DkB,OAAO,EAAEA,CAAA,KAAMb,eAAe,CAACC,KAAK,CAAE;QAAAW,QAAA,eAEtChD,OAAA;UAAK+C,SAAS,EAAC,YAAY;UAAAC,QAAA,gBACzBhD,OAAA;YAAK+C,SAAS,EAAC,YAAY;YAAAC,QAAA,EAAC;UAAC;YAAAE,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAK,CAAC,eACnCrD,OAAA;YAAK+C,SAAS,EAAC,WAAW;YAAAC,QAAA,EAAEzB,IAAI,CAACO;UAAO;YAAAoB,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAM,CAAC;QAAA;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAC5C;MAAC,GATD,GAAG9B,IAAI,CAACQ,IAAI,IAAIM,KAAK,EAAE;QAAAa,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAUzB,CACN;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACC,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEV,CAAC;AAACjD,EAAA,CArMIH,UAAqC;AAAAsD,EAAA,GAArCtD,UAAqC;AAuM3C,eAAeA,UAAU;AAAC,IAAAsD,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}